# Example configuration for my-base resilience patterns
# Copy this to your application.yml and customize as needed

my-base:
  resilience:
    circuit-breaker:
      failure-rate-threshold: 50
      wait-duration-in-open-state: 60s
      sliding-window-size: 100
      minimum-number-of-calls: 10
      slow-call-duration-threshold: 2s
      slow-call-rate-threshold: 100
      automatic-transition-from-open-to-half-open-enabled: true
    
    retry:
      max-attempts: 3
      wait-duration: 100ms
      interval-function: 100ms
      enable-exponential-backoff: false
      multiplier: 2.0
      max-wait-duration: 10s
    
    bulkhead:
      max-concurrent-calls: 10
      max-wait-duration: 100ms
      max-concurrent-calls-per-thread: 5
    
    time-limiter:
      timeout-duration: 5s
      cancel-running-future: true

# Alternative configuration using Spring Boot's native resilience4j properties
resilience4j:
  circuitbreaker:
    instances:
      default:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 60s
        sliding-window-size: 100
        minimum-number-of-calls: 10
        slow-call-duration-threshold: 2s
        slow-call-rate-threshold: 100
        automatic-transition-from-open-to-half-open-enabled: true
  
  retry:
    instances:
      default:
        max-attempts: 3
        wait-duration: 100ms
        retry-exceptions:
          - java.lang.Exception
  
  bulkhead:
    instances:
      default:
        max-concurrent-calls: 10
        max-wait-duration: 100ms
  
  timelimiter:
    instances:
      default:
        timeout-duration: 5s
        cancel-running-future: true

# Logging configuration for resilience patterns
logging:
  level:
    io.github.resilience4j: DEBUG
    com.mycompany.base.core.resilience: DEBUG
